{"ts":1364887087929,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * index.js\n * OAuth 2.0 provider\n *\n * @author Amir Malik\n */\n\nvar EventEmitter = require('events').EventEmitter,\n     querystring = require('querystring'),\n      serializer = require('serializer');\n\nfunction parse_authorization(authorization) {\n  if(!authorization)\n    return null;\n\n  var parts = authorization.split(' ');\n\n  if(parts.length != 2 || parts[0] != 'Basic')\n    return null;\n\n  var creds = new Buffer(parts[1], 'base64').toString(),\n          i = creds.indexOf(':');\n\n  if(i == -1)\n    return null;\n\n  var username = creds.slice(0, i);\n      password = creds.slice(i + 1);\n\n  return [username, password];\n}\n\nfunction OAuth2Provider(options) {\n  if(arguments.length != 1) {\n    console.warn('OAuth2Provider(crypt_key, sign_key) constructor has been deprecated, yo.');\n\n    options = {\n      crypt_key: arguments[0],\n      sign_key: arguments[1],\n    };\n  }\n\n  options['authorize_uri'] = options['authorize_uri'] || '/oauth/authorize';\n  options['access_token_uri'] = options['access_token_uri'] || '/oauth/access_token';\n\n  this.options = options;\n  this.serializer = serializer.createSecureSerializer(this.options.crypt_key, this.options.sign_key);\n}\n\nOAuth2Provider.prototype = new EventEmitter();\n\nOAuth2Provider.prototype.generateAccessToken = function(user_id, client_id, extra_data) {\n  var out = {\n    access_token: this.serializer.stringify([user_id, client_id, +new Date, extra_data]),\n    refresh_token: null,\n  };\n\n  return out;\n};\n\nOAuth2Provider.prototype.login = function() {\n  var self = this;\n\n  return function(req, res, next) {\n    var data, atok, user_id, client_id, grant_date, extra_data;\n\n    if(req.query['access_token']) {\n      atok = req.query['access_token'];\n    } else if((req.headers['authorization'] || '').indexOf('Bearer ') == 0) {\n      atok = req.headers['authorization'].replace('Bearer', '').trim();\n    } else {\n      return next();\n    }\n\n    try {\n      data = self.serializer.parse(atok);\n      user_id = data[0];\n      client_id = data[1];\n      grant_date = new Date(data[2]);\n      extra_data = data[3];\n    } catch(e) {\n      res.writeHead(400);\n      return res.end(e.message);\n    }\n\n    self.emit('access_token', req, {\n      user_id: user_id,\n      client_id: client_id,\n      extra_data: extra_data,\n      grant_date: grant_date\n    }, next);\n  };\n};\n\nOAuth2Provider.prototype.oauth = function() {\n  var self = this;\n\n  return function(req, res, next) {\n    var uri = ~req.url.indexOf('?') ? req.url.substr(0, req.url.indexOf('?')) : req.url;\n\n    if(req.method == 'GET' && self.options.authorize_uri == uri) {\n      var    client_id = req.query.client_id,\n          redirect_uri = req.query.redirect_uri;\n\n      if(!client_id || !redirect_uri) {\n        res.writeHead(400);\n        return res.end('client_id and redirect_uri required');\n      }\n\n      // authorization form will be POSTed to same URL, so we'll have all params\n      var authorize_url = req.url;\n\n      self.emit('enforce_login', req, res, authorize_url, function(user_id) {\n        // store user_id in an HMAC-protected encrypted query param\n        authorize_url += '&' + querystring.stringify({x_user_id: self.serializer.stringify(user_id)});\n\n        // user is logged in, render approval page\n        self.emit('authorize_form', req, res, client_id, authorize_url);\n      });\n\n    } else if(req.method == 'POST' && self.options.authorize_uri == uri) {\n      var     client_id = (req.query.client_id || req.body.client_id),\n           redirect_uri = (req.query.redirect_uri || req.body.redirect_uri),\n          response_type = (req.query.response_type || req.body.response_type) || 'code',\n                  state = (req.query.state || req.body.state),\n              x_user_id = (req.query.x_user_id || req.body.x_user_id);\n\n      var url = redirect_uri;\n\n      switch(response_type) {\n        case 'code': url += '?'; break;\n        case 'token': url += '#'; break;\n        default:\n          res.writeHead(400);\n          return res.end('invalid response_type requested');\n      }\n\n      if('allow' in req.body) {\n        if('token' == response_type) {\n          var user_id;\n\n          try {\n            user_id = self.serializer.parse(x_user_id);\n          } catch(e) {\n            console.error('allow/token error', e.stack);\n\n            res.writeHead(500);\n            return res.end(e.message);\n          }\n\n          self.emit('create_access_token', user_id, client_id, function(extra_data) {\n            var atok = self.generateAccessToken(user_id, client_id, extra_data);\n\n            if(self.listeners('save_access_token').length > 0)\n              self.emit('save_access_token', user_id, client_id, atok);\n\n            url += querystring.stringify(atok);\n\n            res.writeHead(303, {Location: url});\n            res.end();\n          });\n        } else {\n          var code = serializer.randomString(128);\n\n          self.emit('save_grant', req, client_id, code, function() {\n            var extras = {\n              code: code,\n            };\n\n            // pass back anti-CSRF opaque value\n            if(state)\n              extras['state'] = state;\n\n            url += querystring.stringify(extras);\n\n            res.writeHead(303, {Location: url});\n            res.end();\n          });\n        }\n      } else {\n        url += querystring.stringify({error: 'access_denied'});\n\n        res.writeHead(303, {Location: url});\n        res.end();\n      }\n\n    } else if(req.method == 'POST' && self.options.access_token_uri == uri) {\n      var     client_id = req.body.client_id,\n          client_secret = req.body.client_secret,\n           redirect_uri = req.body.redirect_uri,\n                   code = req.body.code;\n\n      if(!client_id || !client_secret) {\n        var authorization = parse_authorization(req.headers.authorization);\n\n        if(!authorization) {\n          res.writeHead(400);\n          return res.end('client_id and client_secret required');\n        }\n\n        client_id = authorization[0];\n        client_secret = authorization[1];\n      }\n\n      if('password' == req.body.grant_type) {\n        if(self.listeners('client_auth').length == 0) {\n          res.writeHead(401);\n          return res.end('client authentication not supported');\n        }\n\n        self.emit('client_auth', client_id, client_secret, req.body.username, req.body.password, function(err, user_id) {\n          if(err) {\n            res.writeHead(401);\n            return res.end(err.message);\n          }\n\n          res.writeHead(200, {'Content-type': 'application/json'});\n\n          self._createAccessToken(user_id, client_id, function(atok) {\n            res.end(JSON.stringify(atok));\n          });\n        });\n      } else {\n        self.emit('lookup_grant', client_id, client_secret, code, function(err, user_id) {\n          if(err) {\n            res.writeHead(400);\n            return res.end(err.message);\n          }\n\n          res.writeHead(200, {'Content-type': 'application/json'});\n\n          self._createAccessToken(user_id, client_id, function(atok) {\n            self.emit('remove_grant', user_id, client_id, code);\n\n            res.end(JSON.stringify(atok));\n          });\n        });\n      }\n\n    } else {\n      return next();\n    }\n  };\n};\n\nOAuth2Provider.prototype._createAccessToken = function(user_id, client_id, cb) {\n  var self = this;\n\n  this.emit('create_access_token', user_id, client_id, function(extra_data) {\n    var atok = self.generateAccessToken(user_id, client_id, extra_data);\n\n    if(self.listeners('save_access_token').length > 0)\n      self.emit('save_access_token', user_id, client_id, atok);\n\n    return cb(atok);\n  });\n};\n\nexports.OAuth2Provider = OAuth2Provider;\n"]],"start1":0,"start2":0,"length1":0,"length2":7655}]],"length":7655}
