{"ts":1369462568653,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function() {\n\n// CommonJS require()\n\nfunction require(p){\n    var path = require.resolve(p)\n      , mod = require.modules[path];\n    if (!mod) throw new Error('failed to require \"' + p + '\"');\n    if (!mod.exports) {\n      mod.exports = {};\n      mod.call(mod.exports, mod, mod.exports, require.relative(path));\n    }\n    return mod.exports;\n  }\n\nrequire.modules = {};\n\nrequire.resolve = function (path){\n    var orig = path\n      , reg = path + '.js'\n      , index = path + '/index.js';\n    return require.modules[reg] && reg\n      || require.modules[index] && index\n      || orig;\n  };\n\nrequire.register = function (path, fn){\n    require.modules[path] = fn;\n  };\n\nrequire.relative = function (parent) {\n    return function(p){\n      if ('.' != p.charAt(0)) return require(p);\n      \n      var path = parent.split('/')\n        , segs = p.split('/');\n      path.pop();\n      \n      for (var i = 0; i < segs.length; i++) {\n        var seg = segs[i];\n        if ('..' == seg) path.pop();\n        else if ('.' != seg) path.push(seg);\n      }\n\n      return require(path.join('/'));\n    };\n  };\n\n\nrequire.register(\"compiler.js\", function(module, exports, require){\n\n/*!\n * Jade - Compiler\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar nodes = require('./nodes')\n  , filters = require('./filters')\n  , doctypes = require('./doctypes')\n  , selfClosing = require('./self-closing')\n  , runtime = require('./runtime')\n  , utils = require('./utils');\n\n\n if (!Object.keys) {\n   Object.keys = function(obj){\n     var arr = [];\n     for (var key in obj) {\n       if (obj.hasOwnProperty(key)) {\n         arr.push(key);\n       }\n     }\n     return arr;\n   }\n }\n\n if (!String.prototype.trimLeft) {\n   String.prototype.trimLeft = function(){\n     return this.replace(/^\\s+/, '');\n   }\n }\n\n\n\n/**\n * Initialize `Compiler` with the given `node`.\n *\n * @param {Node} node\n * @param {Object} options\n * @api public\n */\n\nvar Compiler = module.exports = function Compiler(node, options) {\n  this.options = options = options || {};\n  this.node = node;\n  this.hasCompiledDoctype = false;\n  this.hasCompiledTag = false;\n  this.pp = options.pretty || false;\n  this.debug = false !== options.compileDebug;\n  this.indents = 0;\n  this.parentIndents = 0;\n  if (options.doctype) this.setDoctype(options.doctype);\n};\n\n/**\n * Compiler prototype.\n */\n\nCompiler.prototype = {\n\n  /**\n   * Compile parse tree to JavaScript.\n   *\n   * @api public\n   */\n\n  compile: function(){\n    this.buf = ['var interp;'];\n    if (this.pp) this.buf.push(\"var __indent = [];\");\n    this.lastBufferedIdx = -1;\n    this.visit(this.node);\n    return this.buf.join('\\n');\n  },\n\n  /**\n   * Sets the default doctype `name`. Sets terse mode to `true` when\n   * html 5 is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {string} name\n   * @api public\n   */\n\n  setDoctype: function(name){\n    name = (name && name.toLowerCase()) || 'default';\n    this.doctype = doctypes[name] || '<!DOCTYPE ' + name + '>';\n    this.terse = this.doctype.toLowerCase() == '<!doctype html>';\n    this.xml = 0 == this.doctype.indexOf('<?xml');\n  },\n\n  /**\n   * Buffer the given `str` optionally escaped.\n   *\n   * @param {String} str\n   * @param {Boolean} esc\n   * @api public\n   */\n\n  buffer: function(str, esc){\n    if (esc) str = utils.escape(str);\n\n    if (this.lastBufferedIdx == this.buf.length) {\n      this.lastBuffered += str;\n      this.buf[this.lastBufferedIdx - 1] = \"buf.push('\" + this.lastBuffered + \"');\"\n    } else {\n      this.buf.push(\"buf.push('\" + str + \"');\");\n      this.lastBuffered = str;\n      this.lastBufferedIdx = this.buf.length;\n    }\n  },\n\n  /**\n   * Buffer an indent based on the current `indent`\n   * property and an additional `offset`.\n   *\n   * @param {Number} offset\n   * @param {Boolean} newline\n   * @api public\n   */\n\n  prettyIndent: function(offset, newline){\n    offset = offset || 0;\n    newline = newline ? '\\\\n' : '';\n    this.buffer(newline + Array(this.indents + offset).join('  '));\n    if (this.parentIndents)\n      this.buf.push(\"buf.push.apply(buf, __indent);\");\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visit: function(node){\n    var debug = this.debug;\n\n    if (debug) {\n      this.buf.push('__jade.unshift({ lineno: ' + node.line\n        + ', filename: ' + (node.filename\n          ? JSON.stringify(node.filename)\n          : '__jade[0].filename')\n        + ' });');\n    }\n\n    // Massive hack to fix our context\n    // stack for - else[ if] etc\n    if (false === node.debug && this.debug) {\n      this.buf.pop();\n      this.buf.pop();\n    }\n\n    this.visitNode(node);\n\n    if (debug) this.buf.push('__jade.shift();');\n  },\n\n  /**\n   * Visit `node`.\n   *\n   * @param {Node} node\n   * @api public\n   */\n\n  visitNode: function(node){\n    var name = node.constructor.name\n      || node.constructor.toString().match(/function ([^(\\s]+)()/)[1];\n    return this['visit' + name](node);\n  },\n\n  /**\n   * Visit case `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitCase: function(node){\n    var _ = this.withinCase;\n    this.withinCase = true;\n    this.buf.push('switch (' + node.expr + '){');\n    this.visit(node.block);\n    this.buf.push('}');\n    this.withinCase = _;\n  },\n\n  /**\n   * Visit when `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitWhen: function(node){\n    if ('default' == node.expr) {\n      this.buf.push('default:');\n    } else {\n      this.buf.push('case ' + node.expr + ':');\n    }\n    this.visit(node.block);\n    this.buf.push('  break;');\n  },\n\n  /**\n   * Visit literal `node`.\n   *\n   * @param {Literal} node\n   * @api public\n   */\n\n  visitLiteral: function(node){\n    var str = node.str.replace(/\\n/g, '\\\\\\\\n');\n    this.buffer(str);\n  },\n\n  /**\n   * Visit all nodes in `block`.\n   *\n   * @param {Block} block\n   * @api public\n   */\n\n  visitBlock: function(block){\n    var len = block.nodes.length\n      , escape = this.escape\n      , pp = this.pp\n\n    // Block keyword has a special meaning in mixins\n    if (this.parentIndents && block.mode) {\n      if (pp) this.buf.push(\"__indent.push('\" + Array(this.indents + 1).join('  ') + \"');\")\n      this.buf.push('block && block();');\n      if (pp) this.buf.push(\"__indent.pop();\")\n      return;\n    }\n\n    // Pretty print multi-line text\n    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)\n      this.prettyIndent(1, true);\n\n    for (var i = 0; i < len; ++i) {\n      // Pretty print text\n      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)\n        this.prettyIndent(1, false);\n\n      this.visit(block.nodes[i]);\n      // Multiple text nodes are separated by newlines\n      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)\n        this.buffer('\\\\n');\n    }\n  },\n\n  /**\n   * Visit `doctype`. Sets terse mode to `true` when html 5\n   * is used, causing self-closing tags to end with \">\" vs \"/>\",\n   * and boolean attributes are not mirrored.\n   *\n   * @param {Doctype} doctype\n   * @api public\n   */\n\n  visitDoctype: function(doctype){\n    if (doctype && (doctype.val || !this.doctype)) {\n      this.setDoctype(doctype.val || 'default');\n    }\n\n    if (this.doctype) this.buffer(this.doctype);\n    this.hasCompiledDoctype = true;\n  },\n\n  /**\n   * Visit `mixin`, generating a function that\n   * may be called within the template.\n   *\n   * @param {Mixin} mixin\n   * @api public\n   */\n\n  visitMixin: function(mixin){\n    var name = mixin.name.replace(/-/g, '_') + '_mixin'\n      , args = mixin.args || ''\n      , block = mixin.block\n      , attrs = mixin.attrs\n      , pp = this.pp;\n\n    if (mixin.call) {\n      if (pp) this.buf.push(\"__indent.push('\" + Array(this.indents + 1).join('  ') + \"');\")\n      if (block || attrs.length) {\n\n        this.buf.push(name + '.call({');\n\n        if (block) {\n          this.buf.push('block: function(){');\n\n          // Render block with no indents, dynamically added when rendered\n          this.parentIndents++;\n          var _indents = this.indents;\n          this.indents = 0;\n          this.visit(mixin.block);\n          this.indents = _indents;\n          this.parentIndents--;\n\n          if (attrs.length) {\n            this.buf.push('},');\n          } else {\n            this.buf.push('}');\n          }\n        }\n\n        if (attrs.length) {\n          var val = this.attrs(attrs);\n          if (val.inherits) {\n            this.buf.push('attributes: merge({' + val.buf\n                + '}, attributes), escaped: merge(' + val.escaped + ', escaped, true)');\n          } else {\n            this.buf.push('attributes: {' + val.buf + '}, escaped: ' + val.escaped);\n          }\n        }\n\n        if (args) {\n          this.buf.push('}, ' + args + ');');\n        } else {\n          this.buf.push('});');\n        }\n\n      } else {\n        this.buf.push(name + '(' + args + ');');\n      }\n      if (pp) this.buf.push(\"__indent.pop();\")\n    } else {\n      this.buf.push('var ' + name + ' = function(' + args + '){');\n      this.buf.push('var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};');\n      this.parentIndents++;\n      this.visit(block);\n      this.parentIndents--;\n      this.buf.push('};');\n    }\n  },\n\n  /**\n   * Visit `tag` buffering tag markup, generating\n   * attributes, visiting the `tag`'s code and block.\n   *\n   * @param {Tag} tag\n   * @api public\n   */\n\n  visitTag: function(tag){\n    this.indents++;\n    var name = tag.name\n      , pp = this.pp;\n\n    if (tag.buffer) name = \"' + (\" + name + \") + '\";\n\n    if (!this.hasCompiledTag) {\n      if (!this.hasCompiledDoctype && 'html' == name) {\n        this.visitDoctype();\n      }\n      this.hasCompiledTag = true;\n    }\n\n    // pretty print\n    if (pp && !tag.isInline())\n      this.prettyIndent(0, true);\n\n    if ((~selfClosing.indexOf(name) || tag.selfClosing) && !this.xml) {\n      this.buffer('<' + name);\n      this.visitAttributes(tag.attrs);\n      this.terse\n        ? this.buffer('>')\n        : this.buffer('/>');\n    } else {\n      // Optimize attributes buffering\n      if (tag.attrs.length) {\n        this.buffer('<' + name);\n        if (tag.attrs.length) this.visitAttributes(tag.attrs);\n        this.buffer('>');\n      } else {\n        this.buffer('<' + name + '>');\n      }\n      if (tag.code) this.visitCode(tag.code);\n      this.escape = 'pre' == tag.name;\n      this.visit(tag.block);\n\n      // pretty print\n      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())\n        this.prettyIndent(0, true);\n\n      this.buffer('</' + name + '>');\n    }\n    this.indents--;\n  },\n\n  /**\n   * Visit `filter`, throwing when the filter does not exist.\n   *\n   * @param {Filter} filter\n   * @api public\n   */\n\n  visitFilter: function(filter){\n    var fn = filters[filter.name];\n\n    // unknown filter\n    if (!fn) {\n      if (filter.isASTFilter) {\n        throw new Error('unknown ast filter \"' + filter.name + ':\"');\n      } else {\n        throw new Error('unknown filter \":' + filter.name + '\"');\n      }\n    }\n\n    if (filter.isASTFilter) {\n      this.buf.push(fn(filter.block, this, filter.attrs));\n    } else {\n      var text = filter.block.nodes.map(function(node){ return node.val }).join('\\n');\n      filter.attrs = filter.attrs || {};\n      filter.attrs.filename = this.options.filename;\n      this.buffer(utils.text(fn(text, filter.attrs)));\n    }\n  },\n\n  /**\n   * Visit `text` node.\n   *\n   * @param {Text} text\n   * @api public\n   */\n\n  visitText: function(text){\n    text = utils.text(text.val.replace(/\\\\/g, '_SLASH_'));\n    if (this.escape) text = escape(text);\n    text = text.replace(/_SLASH_/g, '\\\\\\\\');\n    this.buffer(text);\n  },\n\n  /**\n   * Visit a `comment`, only buffering when the buffer flag is set.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitComment: function(comment){\n    if (!comment.buffer) return;\n    if (this.pp) this.prettyIndent(1, true);\n    this.buffer('<!--' + utils.escape(comment.val) + '-->');\n  },\n\n  /**\n   * Visit a `BlockComment`.\n   *\n   * @param {Comment} comment\n   * @api public\n   */\n\n  visitBlockComment: function(comment){\n    if (!comment.buffer) return;\n    if (0 == comment.val.trim().indexOf('if')) {\n      this.buffer('<!--[' + comment.val.trim() + ']>');\n      this.visit(comment.block);\n      this.buffer('<![endif]-->');\n    } else {\n      this.buffer('<!--' + comment.val);\n      this.visit(comment.block);\n      this.buffer('-->');\n    }\n  },\n\n  /**\n   * Visit `code`, respecting buffer / escape flags.\n   * If the code is followed by a block, wrap it in\n   * a self-calling function.\n   *\n   * @param {Code} code\n   * @api public\n   */\n\n  visitCode: function(code){\n    // Wrap code blocks with {}.\n    // we only wrap unbuffered code blocks ATM\n    // since they are usually flow control\n\n    // Buffer code\n    if (code.buffer) {\n      var val = code.val.trimLeft();\n      this.buf.push('var __val__ = ' + val);\n      val = 'null == __val__ ? \"\" : __val__';\n      if (code.escape) val = 'escape(' + val + ')';\n      this.buf.push(\"buf.push(\" + val + \");\");\n    } else {\n      this.buf.push(code.val);\n    }\n\n    // Block support\n    if (code.block) {\n      if (!code.buffer) this.buf.push('{');\n      this.visit(code.block);\n      if (!code.buffer) this.buf.push('}');\n    }\n  },\n\n  /**\n   * Visit `each` block.\n   *\n   * @param {Each} each\n   * @api public\n   */\n\n  visitEach: function(each){\n    this.buf.push(''\n      + '// iterate ' + each.obj + '\\n'\n      + ';(function(){\\n'\n      + '  if (\\'number\\' == typeof ' + each.obj + '.length) {\\n');\n\n    if (each.alternative) {\n      this.buf.push('  if (' + each.obj + '.length) {');\n    }\n\n    this.buf.push(''\n      + '    for (var ' + each.key + ' = 0, $$l = ' + each.obj + '.length; ' + each.key + ' < $$l; ' + each.key + '++) {\\n'\n      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n    this.buf.push('    }\\n');\n\n    if (each.alternative) {\n      this.buf.push('  } else {');\n      this.visit(each.alternative);\n      this.buf.push('  }');\n    }\n\n    this.buf.push(''\n      + '  } else {\\n'\n      + '    var $$l = 0;\\n'\n      + '    for (var ' + each.key + ' in ' + each.obj + ') {\\n'\n      + '      $$l++;'\n       + '      if (' + each.obj + '.hasOwnProperty(' + each.key + ')){'\n      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\\n');\n\n    this.visit(each.block);\n\n     this.buf.push('      }\\n');\n\n    this.buf.push('    }\\n');\n    if (each.alternative) {\n      this.buf.push('    if ($$l === 0) {');\n      this.visit(each.alternative);\n      this.buf.push('    }');\n    }\n    this.buf.push('  }\\n}).call(this);\\n');\n  },\n\n  /**\n   * Visit `attrs`.\n   *\n   * @param {Array} attrs\n   * @api public\n   */\n\n  visitAttributes: function(attrs){\n    var val = this.attrs(attrs);\n    if (val.inherits) {\n      this.buf.push(\"buf.push(attrs(merge({ \" + val.buf +\n          \" }, attributes), merge(\" + val.escaped + \", escaped, true)));\");\n    } else if (val.constant) {\n      eval('var buf={' + val.buf + '};');\n      this.buffer(runtime.attrs(buf, JSON.parse(val.escaped)), true);\n    } else {\n      this.buf.push(\"buf.push(attrs({ \" + val.buf + \" }, \" + val.escaped + \"));\");\n    }\n  },\n\n  /**\n   * Compile attributes.\n   */\n\n  attrs: function(attrs){\n    var buf = []\n      , classes = []\n      , escaped = {}\n      , constant = attrs.every(function(attr){ return isConstant(attr.val) })\n      , inherits = false;\n\n    if (this.terse) buf.push('terse: true');\n\n    attrs.forEach(function(attr){\n      if (attr.name == 'attributes') return inherits = true;\n      escaped[attr.name] = attr.escaped;\n      if (attr.name == 'class') {\n        classes.push('(' + attr.val + ')');\n      } else {\n        var pair = \"'\" + attr.name + \"':(\" + attr.val + ')';\n        buf.push(pair);\n      }\n    });\n\n    if (classes.length) {\n      classes = classes.join(\" + ' ' + \");\n      buf.push(\"class: \" + classes);\n    }\n\n    return {\n      buf: buf.join(', ').replace('class:', '\"class\":'),\n      escaped: JSON.stringify(escaped),\n      inherits: inherits,\n      constant: constant\n    };\n  }\n};\n\n/**\n * Check if expression can be evaluated to a constant\n *\n * @param {String} expression\n * @return {Boolean}\n * @api private\n */\n\nfunction isConstant(val){\n  // Check strings/literals\n  if (/^ *(\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"|'([^'\\\\]*(\\\\.[^'\\\\]*)*)'|true|false|null|undefined) *$/i.test(val))\n    return true;\n\n  // Check numbers\n  if (!isNaN(Number(val)))\n    return true;\n\n  // Check arrays\n  var matches;\n  if (matches = /^ *\\[(.*)\\] *$/.exec(val))\n    return matches[1].split(',').every(isConstant);\n\n  return false;\n}\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nfunction escape(html){\n  return String(html)\n    .replace(/&(?!\\w+;)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}\n\n}); // module: compiler.js\n\nrequire.register(\"doctypes.js\", function(module, exports, require){\n\n/*!\n * Jade - doctypes\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = {\n    '5': '<!DOCTYPE html>'\n  , 'default': '<!DOCTYPE html>'\n  , 'xml': '<?xml version=\"1.0\" encoding=\"utf-8\" ?>'\n  , 'transitional': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">'\n  , 'strict': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">'\n  , 'frameset': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">'\n  , '1.1': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">'\n  , 'basic': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">'\n  , 'mobile': '<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">'\n};\n}); // module: doctypes.js\n\nrequire.register(\"filters.js\", function(module, exports, require){\n\n/*!\n * Jade - filters\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = {\n  \n  /**\n   * Wrap text with CDATA block.\n   */\n  \n  cdata: function(str){\n    return '<![CDATA[\\\\n' + str + '\\\\n]]>';\n  },\n  \n  /**\n   * Transform sass to css, wrapped in style tags.\n   */\n  \n  sass: function(str){\n    str = str.replace(/\\\\n/g, '\\n');\n    var sass = require('sass').render(str).replace(/\\n/g, '\\\\n');\n    return '<style type=\"text/css\">' + sass + '</style>'; \n  },\n  \n  /**\n   * Transform stylus to css, wrapped in style tags.\n   */\n  \n  stylus: function(str, options){\n    var ret;\n    str = str.replace(/\\\\n/g, '\\n');\n    var stylus = require('stylus');\n    stylus(str, options).render(function(err, css){\n      if (err) throw err;\n      ret = css.replace(/\\n/g, '\\\\n');\n    });\n    return '<style type=\"text/css\">' + ret + '</style>'; \n  },\n  \n  /**\n   * Transform less to css, wrapped in style tags.\n   */\n  \n  less: function(str){\n    var ret;\n    str = str.replace(/\\\\n/g, '\\n');\n    require('less').render(str, function(err, css){\n      if (err) throw err;\n      ret = '<style type=\"text/css\">' + css.replace(/\\n/g, '\\\\n') + '</style>';  \n    });\n    return ret;\n  },\n  \n  /**\n   * Transform markdown to html.\n   */\n  \n  markdown: function(str){\n    var md;\n\n    // support markdown / discount\n    try {\n      md = require('markdown');\n    } catch (err){\n      try {\n        md = require('discount');\n      } catch (err) {\n        try {\n          md = require('markdown-js');\n        } catch (err) {\n          try {\n            md = require('marked');\n          } catch (err) {\n            throw new\n              Error('Cannot find markdown library, install markdown, discount, or marked.');\n          }\n        }\n      }\n    }\n\n    str = str.replace(/\\\\n/g, '\\n');\n    return md.parse(str).replace(/\\n/g, '\\\\n').replace(/'/g,'&#39;');\n  },\n  \n  /**\n   * Transform coffeescript to javascript.\n   */\n\n  coffeescript: function(str){\n    var js = require('coffee-script').compile(str).replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n    return '<script type=\"text/javascript\">\\\\n' + js + '</script>';\n  }\n};\n\n}); // module: filters.js\n\nrequire.register(\"inline-tags.js\", function(module, exports, require){\n\n/*!\n * Jade - inline tags\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = [\n    'a'\n  , 'abbr'\n  , 'acronym'\n  , 'b'\n  , 'br'\n  , 'code'\n  , 'em'\n  , 'font'\n  , 'i'\n  , 'img'\n  , 'ins'\n  , 'kbd'\n  , 'map'\n  , 'samp'\n  , 'small'\n  , 'span'\n  , 'strong'\n  , 'sub'\n  , 'sup'\n];\n}); // module: inline-tags.js\n\nrequire.register(\"jade.js\", function(module, exports, require){\n/*!\n * Jade\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Parser = require('./parser')\n  , Lexer = require('./lexer')\n  , Compiler = require('./compiler')\n  , runtime = require('./runtime')\n\n/**\n * Library version.\n */\n\nexports.version = '0.27.6';\n\n/**\n * Expose self closing tags.\n */\n\nexports.selfClosing = require('./self-closing');\n\n/**\n * Default supported doctypes.\n */\n\nexports.doctypes = require('./doctypes');\n\n/**\n * Text filters.\n */\n\nexports.filters = require('./filters');\n\n/**\n * Utilities.\n */\n\nexports.utils = require('./utils');\n\n/**\n * Expose `Compiler`.\n */\n\nexports.Compiler = Compiler;\n\n/**\n * Expose `Parser`.\n */\n\nexports.Parser = Parser;\n\n/**\n * Expose `Lexer`.\n */\n\nexports.Lexer = Lexer;\n\n/**\n * Nodes.\n */\n\nexports.nodes = require('./nodes');\n\n/**\n * Jade runtime helpers.\n */\n\nexports.runtime = runtime;\n\n/**\n * Template function cache.\n */\n\nexports.cache = {};\n\n/**\n * Parse the given `str` of jade and return a function body.\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction parse(str, options){\n  try {\n    // Parse\n    var parser = new Parser(str, options.filename, options);\n\n    // Compile\n    var compiler = new (options.compiler || Compiler)(parser.parse(), options)\n      , js = compiler.compile();\n\n    // Debug compiler\n    if (options.debug) {\n      console.error('\\nCompiled Function:\\n\\n\\033[90m%s\\033[0m', js.replace(/^/gm, '  '));\n    }\n\n    return ''\n      + 'var buf = [];\\n'\n      + (options.self\n        ? 'var self = locals || {};\\n' + js\n        : 'with (locals || {}) {\\n' + js + '\\n}\\n')\n      + 'return buf.join(\"\");';\n  } catch (err) {\n    parser = parser.context();\n    runtime.rethrow(err, parser.filename, parser.lexer.lineno);\n  }\n}\n\n/**\n * Strip any UTF-8 BOM off of the start of `str`, if it exists.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction stripBOM(str){\n  return 0xFEFF == str.charCodeAt(0)\n    ? str.substring(1)\n    : str;\n}\n\n/**\n * Compile a `Function` representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled template\n *   - `client` when `true` the helper functions `escape()` etc will reference `jade.escape()`\n *      for use with the Jade client-side runtime.js\n *\n * @param {String} str\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\nexports.compile = function(str, options){\n  var options = options || {}\n    , client = options.client\n    , filename = options.filename\n      ? JSON.stringify(options.filename)\n      : 'undefined'\n    , fn;\n\n  str = stripBOM(String(str));\n\n  if (options.compileDebug !== false) {\n    fn = [\n        'var __jade = [{ lineno: 1, filename: ' + filename + ' }];'\n      , 'try {'\n      , parse(str, options)\n      , '} catch (err) {'\n      , '  rethrow(err, __jade[0].filename, __jade[0].lineno);'\n      , '}'\n    ].join('\\n');\n  } else {\n    fn = parse(str, options);\n  }\n\n  if (client) {\n    fn = 'attrs = attrs || jade.attrs; escape = escape || jade.escape; rethrow = rethrow || jade.rethrow; merge = merge || jade.merge;\\n' + fn;\n  }\n\n  fn = new Function('locals, attrs, escape, rethrow, merge', fn);\n\n  if (client) return fn;\n\n  return function(locals){\n    return fn(locals, runtime.attrs, runtime.escape, runtime.rethrow, runtime.merge);\n  };\n};\n\n/**\n * Render the given `str` of jade and invoke\n * the callback `fn(err, str)`.\n *\n * Options:\n *\n *   - `cache` enable template caching\n *   - `filename` filename required for `include` / `extends` and caching\n *\n * @param {String} str\n * @param {Object|Function} options or fn\n * @param {Function} fn\n * @api public\n */\n\nexports.render = function(str, options, fn){\n  // swap args\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  // cache requires .filename\n  if (options.cache && !options.filename) {\n    return fn(new Error('the \"filename\" option is required for caching'));\n  }\n\n  try {\n    var path = options.filename;\n    var tmpl = options.cache\n      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))\n      : exports.compile(str, options);\n    fn(null, tmpl(options));\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Render a Jade file at the given `path` and callback `fn(err, str)`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function} fn\n * @api public\n */\n\nexports.renderFile = function(path, options, fn){\n  var key = path + ':string';\n\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  try {\n    options.filename = path;\n    var str = options.cache\n      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))\n      : fs.readFileSync(path, 'utf8');\n    exports.render(str, options, fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Express support.\n */\n\nexports.__express = exports.renderFile;\n\n}); // module: jade.js\n\nrequire.register(\"lexer.js\", function(module, exports, require){\n/*!\n * Jade - Lexer\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nvar utils = require('./utils');\n\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * Options:\n *\n *   - `colons` allow colons for attr delimiters\n *\n * @param {String} str\n * @param {Object} options\n * @api private\n */\n\nvar Lexer = module.exports = function Lexer(str, options) {\n  options = options || {};\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.colons = options.colons;\n  this.deferredTokens = [];\n  this.lastIndents = 0;\n  this.lineno = 1;\n  this.stash = [];\n  this.indentStack = [];\n  this.indentRe = null;\n  this.pipeless = false;\n};\n\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n  \n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n  \n  tok: function(type, val){\n    return {\n        type: type\n      , line: this.lineno\n      , val: val\n    }\n  },\n  \n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n  \n  consume: function(len){\n    this.input = this.input.substr(len);\n  },\n  \n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n  \n  scan: function(regexp, type){\n    var captures;\n    if (captures = regexp.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok(type, captures[1]);\n    }\n  },\n  \n  /**\n   * Defer the given `tok`.\n   *\n   * @param {Object} tok\n   * @api private\n   */\n  \n  defer: function(tok){\n    this.deferredTokens.push(tok);\n  },\n  \n  /**\n   * Lookahead `n` tokens.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  \n  lookahead: function(n){\n    var fetch = n - this.stash.length;\n    while (fetch-- > 0) this.stash.push(this.next());\n    return this.stash[--n];\n  },\n  \n  /**\n   * Return the indexOf `start` / `end` delimiters.\n   *\n   * @param {String} start\n   * @param {String} end\n   * @return {Number}\n   * @api private\n   */\n  \n  indexOfDelimiters: function(start, end){\n    var str = this.input\n      , nstart = 0\n      , nend = 0\n      , pos = 0;\n    for (var i = 0, len = str.length; i < len; ++i) {\n      if (start == str.charAt(i)) {\n        ++nstart;\n      } else if (end == str.charAt(i)) {\n        if (++nend == nstart) {\n          pos = i;\n          break;\n        }\n      }\n    }\n    return pos;\n  },\n  \n  /**\n   * Stashed token.\n   */\n  \n  stashed: function() {\n    return this.stash.length\n      && this.stash.shift();\n  },\n  \n  /**\n   * Deferred token.\n   */\n  \n  deferred: function() {\n    return this.deferredTokens.length \n      && this.deferredTokens.shift();\n  },\n  \n  /**\n   * end-of-source.\n   */\n  \n  eos: function() {\n    if (this.input.length) return;\n    if (this.indentStack.length) {\n      this.indentStack.shift();\n      return this.tok('outdent');\n    } else {\n      return this.tok('eos');\n    }\n  },\n\n  /**\n   * Blank line.\n   */\n  \n  blank: function() {\n    var captures;\n    if (captures = /^\\n *\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n\n      ++this.lineno;\n      if (this.pipeless) return this.tok('text', '');\n      return this.next();\n    }\n  },\n\n  /**\n   * Comment.\n   */\n  \n  comment: function() {\n    var captures;\n    if (captures = /^ *\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      return tok;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n\n  interpolation: function() {\n    var captures;\n    if (captures = /^#\\{(.*?)\\}/.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok('interpolation', captures[1]);\n    }\n  },\n\n  /**\n   * Tag.\n   */\n  \n  tag: function() {\n    var captures;\n    if (captures = /^(\\w[-:\\w]*)(\\/?)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok, name = captures[1];\n      if (':' == name[name.length - 1]) {\n        name = name.slice(0, -1);\n        tok = this.tok('tag', name);\n        this.defer(this.tok(':'));\n        while (' ' == this.input[0]) this.input = this.input.substr(1);\n      } else {\n        tok = this.tok('tag', name);\n      }\n      tok.selfClosing = !! captures[2];\n      return tok;\n    }\n  },\n  \n  /**\n   * Filter.\n   */\n  \n  filter: function() {\n    return this.scan(/^:(\\w+)/, 'filter');\n  },\n  \n  /**\n   * Doctype.\n   */\n  \n  doctype: function() {\n    return this.scan(/^(?:!!!|doctype) *([^\\n]+)?/, 'doctype');\n  },\n\n  /**\n   * Id.\n   */\n  \n  id: function() {\n    return this.scan(/^#([\\w-]+)/, 'id');\n  },\n  \n  /**\n   * Class.\n   */\n  \n  className: function() {\n    return this.scan(/^\\.([\\w-]+)/, 'class');\n  },\n  \n  /**\n   * Text.\n   */\n  \n  text: function() {\n    return this.scan(/^(?:\\| ?| ?)?([^\\n]+)/, 'text');\n  },\n\n  /**\n   * Extends.\n   */\n  \n  \"extends\": function() {\n    return this.scan(/^extends? +([^\\n]+)/, 'extends');\n  },\n\n  /**\n   * Block prepend.\n   */\n  \n  prepend: function() {\n    var captures;\n    if (captures = /^prepend +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'prepend'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n  \n  /**\n   * Block append.\n   */\n  \n  append: function() {\n    var captures;\n    if (captures = /^append +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = 'append'\n        , name = captures[1]\n        , tok = this.tok('block', name);\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Block.\n   */\n  \n  block: function() {\n    var captures;\n    if (captures = /^block\\b *(?:(prepend|append) +)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var mode = captures[1] || 'replace'\n        , name = captures[2]\n        , tok = this.tok('block', name);\n\n      tok.mode = mode;\n      return tok;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n  \n  yield: function() {\n    return this.scan(/^yield */, 'yield');\n  },\n\n  /**\n   * Include.\n   */\n  \n  include: function() {\n    return this.scan(/^include +([^\\n]+)/, 'include');\n  },\n\n  /**\n   * Case.\n   */\n  \n  \"case\": function() {\n    return this.scan(/^case +([^\\n]+)/, 'case');\n  },\n\n  /**\n   * When.\n   */\n  \n  when: function() {\n    return this.scan(/^when +([^:\\n]+)/, 'when');\n  },\n\n  /**\n   * Default.\n   */\n  \n  \"default\": function() {\n    return this.scan(/^default */, 'default');\n  },\n\n  /**\n   * Assignment.\n   */\n  \n  assignment: function() {\n    var captures;\n    if (captures = /^(\\w+) += *([^;\\n]+)( *;? *)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var name = captures[1]\n        , val = captures[2];\n      return this.tok('code', 'var ' + name + ' = (' + val + ');');\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n  \n  call: function(){\n    var captures;\n    if (captures = /^\\+([-\\w]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('call', captures[1]);\n      \n      // Check for args (not attributes)\n      if (captures = /^ *\\((.*?)\\)/.exec(this.input)) {\n        if (!/^ *[-\\w]+ *=/.test(captures[1])) {\n          this.consume(captures[0].length);\n          tok.args = captures[1];\n        }\n      }\n      \n      return tok;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n\n  mixin: function(){\n    var captures;\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))?/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2];\n      return tok;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n  \n  conditional: function() {\n    var captures;\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1]\n        , js = captures[2];\n\n      switch (type) {\n        case 'if': js = 'if (' + js + ')'; break;\n        case 'unless': js = 'if (!(' + js + '))'; break;\n        case 'else if': js = 'else if (' + js + ')'; break;\n        case 'else': js = 'else'; break;\n      }\n\n      return this.tok('code', js);\n    }\n  },\n\n  /**\n   * While.\n   */\n  \n  \"while\": function() {\n    var captures;\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      return this.tok('code', 'while (' + captures[1] + ')');\n    }\n  },\n\n  /**\n   * Each.\n   */\n  \n  each: function() {\n    var captures;\n    if (captures = /^(?:- *)?(?:each|for) +(\\w+)(?: *, *(\\w+))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || '$index';\n      tok.code = captures[3];\n      return tok;\n    }\n  },\n  \n  /**\n   * Code.\n   */\n  \n  code: function() {\n    var captures;\n    if (captures = /^(!?=|-)([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var flags = captures[1];\n      captures[1] = captures[2];\n      var tok = this.tok('code', captures[1]);\n      tok.escape = flags.charAt(0) === '=';\n      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';\n      return tok;\n    }\n  },\n  \n  /**\n   * Attributes.\n   */\n  \n  attrs: function() {\n    if ('(' == this.input.charAt(0)) {\n      var index = this.indexOfDelimiters('(', ')')\n        , str = this.input.substr(1, index-1)\n        , tok = this.tok('attrs')\n        , len = str.length\n        , colons = this.colons\n        , states = ['key']\n        , escapedAttr\n        , key = ''\n        , val = ''\n        , quote\n        , c\n        , p;\n\n      function state(){\n        return states[states.length - 1];\n      }\n\n      function interpolate(attr) {\n        return attr.replace(/(\\\\)?#\\{([^}]+)\\}/g, function(_, escape, expr){\n          return escape\n             ? _\n             : quote + \" + (\" + expr + \") + \" + quote;\n        });\n      }\n\n      this.consume(index + 1);\n      tok.attrs = {};\n      tok.escaped = {};\n\n      function parse(c) {\n        var real = c;\n        // TODO: remove when people fix \":\"\n        if (colons && ':' == c) c = '=';\n        switch (c) {\n          case ',':\n          case '\\n':\n            switch (state()) {\n              case 'expr':\n              case 'array':\n              case 'string':\n              case 'object':\n                val += c;\n                break;\n              default:\n                states.push('key');\n                val = val.trim();\n                key = key.trim();\n                if ('' == key) return;\n                key = key.replace(/^['\"]|['\"]$/g, '').replace('!', '');\n                tok.escaped[key] = escapedAttr;\n                tok.attrs[key] = '' == val\n                  ? true\n                  : interpolate(val);\n                key = val = '';\n            }\n            break;\n          case '=':\n            switch (state()) {\n              case 'key char':\n                key += real;\n                break;\n              case 'val':\n              case 'expr':\n              case 'array':\n              case 'string':\n              case 'object':\n                val += real;\n                break;\n              default:\n                escapedAttr = '!' != p;\n                states.push('val');\n            }\n            break;\n          case '(':\n            if ('val' == state()\n              || 'expr' == state()) states.push('expr');\n            val += c;\n            break;\n          case ')':\n            if ('expr' == state()\n              || 'val' == state()) states.pop();\n            val += c;\n            break;\n          case '{':\n            if ('val' == state()) states.push('object');\n            val += c;\n            break;\n          case '}':\n            if ('object' == state()) states.pop();\n            val += c;\n            break;\n          case '[':\n            if ('val' == state()) states.push('array');\n            val += c;\n            break;\n          case ']':\n            if ('array' == state()) states.pop();\n            val += c;\n            break;\n          case '\"':\n          case \"'\":\n            switch (state()) {\n              case 'key':\n                states.push('key char');\n                break;\n              case 'key char':\n                states.pop();\n                break;\n              case 'string':\n                if (c == quote) states.pop();\n                val += c;\n                break;\n              default:\n                states.push('string');\n                val += c;\n                quote = c;\n            }\n            break;\n          case '':\n            break;\n          default:\n            switch (state()) {\n              case 'key':\n              case 'key char':\n                key += c;\n                break;\n              default:\n                val += c;\n            }\n        }\n        p = c;\n      }\n\n      for (var i = 0; i < len; ++i) {\n        parse(str.charAt(i));\n      }\n\n      parse(',');\n\n      if ('/' == this.input.charAt(0)) {\n        this.consume(1);\n        tok.selfClosing = true;\n      }\n\n      return tok;\n    }\n  },\n  \n  /**\n   * Indent | Outdent | Newline.\n   */\n  \n  indent: function() {\n    var captures, re;\n\n    // established regexp\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input);\n    // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input);\n\n      // spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    if (captures) {\n      var tok\n        , indents = captures[1].length;\n\n      ++this.lineno;\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        throw new Error('Invalid indentation, you can use tabs or spaces but not both');\n      }\n\n      // blank line\n      if ('\\n' == this.input[0]) return this.tok('newline');\n\n      // outdent\n      if (this.indentStack.length && indents < this.indentStack[0]) {\n        while (this.indentStack.length && this.indentStack[0] > indents) {\n          this.stash.push(this.tok('outdent'));\n          this.indentStack.shift();\n        }\n        tok = this.stash.pop();\n      // indent\n      } else if (indents && indents != this.indentStack[0]) {\n        this.indentStack.unshift(indents);\n        tok = this.tok('indent', indents);\n      // newline\n      } else {\n        tok = this.tok('newline');\n      }\n\n      return tok;\n    }\n  },\n\n  /**\n   * Pipe-less text consumed only when \n   * pipeless is true;\n   */\n\n  pipelessText: function() {\n    if (this.pipeless) {\n      if ('\\n' == this.input[0]) return;\n      var i = this.input.indexOf('\\n');\n      if (-1 == i) i = this.input.length;\n      var str = this.input.substr(0, i);\n      this.consume(str.length);\n      return this.tok('text', str);\n    }\n  },\n\n  /**\n   * ':'\n   */\n\n  colon: function() {\n    return this.scan(/^: */, ':');\n  },\n\n  /**\n   * Return the next token object, or those\n   * previously stashed by lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  advance: function(){\n    return this.stashed()\n      || this.next();\n  },\n  \n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  next: function() {\n    return this.deferred()\n      || this.blank()\n      || this.eos()\n      || this.pipelessText()\n      || this.yield()\n      || this.doctype()\n      || this.interpolation()\n      || this[\"case\"]()\n      || this.when()\n      || this[\"default\"]()\n      || this[\"extends\"]()\n      || this.append()\n      || this.prepend()\n      || this.block()\n      || this.include()\n      || this.mixin()\n      || this.call()\n      || this.conditional()\n      || this.each()\n      || this[\"while\"]()\n      || this.assignment()\n      || this.tag()\n      || this.filter()\n      || this.code()\n      || this.id()\n      || this.className()\n      || this.attrs()\n      || this.indent()\n      || this.comment()\n      || this.colon()\n      || this.text();\n  }\n};\n\n}); // module: lexer.js\n\nrequire.register(\"nodes/attrs.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Attrs\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node'),\n    Block = require('./block');\n\n/**\n * Initialize a `Attrs` node.\n *\n * @api public\n */\n\nvar Attrs = module.exports = function Attrs() {\n  this.attrs = [];\n};\n\n/**\n * Inherit from `Node`.\n */\n\nAttrs.prototype = new Node;\nAttrs.prototype.constructor = Attrs;\n\n\n/**\n * Set attribute `name` to `val`, keep in mind these become\n * part of a raw js object literal, so to quote a value you must\n * '\"quote me\"', otherwise or example 'user.name' is literal JavaScript.\n *\n * @param {String} name\n * @param {String} val\n * @param {Boolean} escaped\n * @return {Tag} for chaining\n * @api public\n */\n\nAttrs.prototype.setAttribute = function(name, val, escaped){\n  this.attrs.push({ name: name, val: val, escaped: escaped });\n  return this;\n};\n\n/**\n * Remove attribute `name` when present.\n *\n * @param {String} name\n * @api public\n */\n\nAttrs.prototype.removeAttribute = function(name){\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      delete this.attrs[i];\n    }\n  }\n};\n\n/**\n * Get attribute value by `name`.\n *\n * @param {String} name\n * @return {String}\n * @api public\n */\n\nAttrs.prototype.getAttribute = function(name){\n  for (var i = 0, len = this.attrs.length; i < len; ++i) {\n    if (this.attrs[i] && this.attrs[i].name == name) {\n      return this.attrs[i].val;\n    }\n  }\n};\n\n}); // module: nodes/attrs.js\n\nrequire.register(\"nodes/block-comment.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - BlockComment\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `BlockComment` with the given `block`.\n *\n * @param {String} val\n * @param {Block} block\n * @param {Boolean} buffer\n * @api public\n */\n\nvar BlockComment = module.exports = function BlockComment(val, block, buffer) {\n  this.block = block;\n  this.val = val;\n  this.buffer = buffer;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nBlockComment.prototype = new Node;\nBlockComment.prototype.constructor = BlockComment;\n\n}); // module: nodes/block-comment.js\n\nrequire.register(\"nodes/block.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Block\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Block` with an optional `node`.\n *\n * @param {Node} node\n * @api public\n */\n\nvar Block = module.exports = function Block(node){\n  this.nodes = [];\n  if (node) this.push(node);\n};\n\n/**\n * Inherit from `Node`.\n */\n\nBlock.prototype = new Node;\nBlock.prototype.constructor = Block;\n\n\n/**\n * Block flag.\n */\n\nBlock.prototype.isBlock = true;\n\n/**\n * Replace the nodes in `other` with the nodes\n * in `this` block.\n *\n * @param {Block} other\n * @api private\n */\n\nBlock.prototype.replace = function(other){\n  other.nodes = this.nodes;\n};\n\n/**\n * Pust the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.push = function(node){\n  return this.nodes.push(node);\n};\n\n/**\n * Check if this block is empty.\n *\n * @return {Boolean}\n * @api public\n */\n\nBlock.prototype.isEmpty = function(){\n  return 0 == this.nodes.length;\n};\n\n/**\n * Unshift the given `node`.\n *\n * @param {Node} node\n * @return {Number}\n * @api public\n */\n\nBlock.prototype.unshift = function(node){\n  return this.nodes.unshift(node);\n};\n\n/**\n * Return the \"last\" block, or the first `yield` node.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.includeBlock = function(){\n  var ret = this\n    , node;\n\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    node = this.nodes[i];\n    if (node.yield) return node;\n    else if (node.textOnly) continue;\n    else if (node.includeBlock) ret = node.includeBlock();\n    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();\n    if (ret.yield) return ret;\n  }\n\n  return ret;\n};\n\n/**\n * Return a clone of this block.\n *\n * @return {Block}\n * @api private\n */\n\nBlock.prototype.clone = function(){\n  var clone = new Block;\n  for (var i = 0, len = this.nodes.length; i < len; ++i) {\n    clone.push(this.nodes[i].clone());\n  }\n  return clone;\n};\n\n\n}); // module: nodes/block.js\n\nrequire.register(\"nodes/case.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Case\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a new `Case` with `expr`.\n *\n * @param {String} expr\n * @api public\n */\n\nvar Case = exports = module.exports = function Case(expr, block){\n  this.expr = expr;\n  this.block = block;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nCase.prototype = new Node;\nCase.prototype.constructor = Case;\n\n\nvar When = exports.When = function When(expr, block){\n  this.expr = expr;\n  this.block = block;\n  this.debug = false;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nWhen.prototype = new Node;\nWhen.prototype.constructor = When;\n\n\n\n}); // module: nodes/case.js\n\nrequire.register(\"nodes/code.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Code\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Code` node with the given code `val`.\n * Code may also be optionally buffered and escaped.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @param {Boolean} escape\n * @api public\n */\n\nvar Code = module.exports = function Code(val, buffer, escape) {\n  this.val = val;\n  this.buffer = buffer;\n  this.escape = escape;\n  if (val.match(/^ *else/)) this.debug = false;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nCode.prototype = new Node;\nCode.prototype.constructor = Code;\n\n}); // module: nodes/code.js\n\nrequire.register(\"nodes/comment.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Comment\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Comment` with the given `val`, optionally `buffer`,\n * otherwise the comment may render in the output.\n *\n * @param {String} val\n * @param {Boolean} buffer\n * @api public\n */\n\nvar Comment = module.exports = function Comment(val, buffer) {\n  this.val = val;\n  this.buffer = buffer;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nComment.prototype = new Node;\nComment.prototype.constructor = Comment;\n\n}); // module: nodes/comment.js\n\nrequire.register(\"nodes/doctype.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Doctype\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Doctype` with the given `val`. \n *\n * @param {String} val\n * @api public\n */\n\nvar Doctype = module.exports = function Doctype(val) {\n  this.val = val;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nDoctype.prototype = new Node;\nDoctype.prototype.constructor = Doctype;\n\n}); // module: nodes/doctype.js\n\nrequire.register(\"nodes/each.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Each\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize an `Each` node, representing iteration\n *\n * @param {String} obj\n * @param {String} val\n * @param {String} key\n * @param {Block} block\n * @api public\n */\n\nvar Each = module.exports = function Each(obj, val, key, block) {\n  this.obj = obj;\n  this.val = val;\n  this.key = key;\n  this.block = block;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nEach.prototype = new Node;\nEach.prototype.constructor = Each;\n\n}); // module: nodes/each.js\n\nrequire.register(\"nodes/filter.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Filter\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node')\n  , Block = require('./block');\n\n/**\n * Initialize a `Filter` node with the given \n * filter `name` and `block`.\n *\n * @param {String} name\n * @param {Block|Node} block\n * @api public\n */\n\nvar Filter = module.exports = function Filter(name, block, attrs) {\n  this.name = name;\n  this.block = block;\n  this.attrs = attrs;\n  this.isASTFilter = !block.nodes.every(function(node){ return node.isText });\n};\n\n/**\n * Inherit from `Node`.\n */\n\nFilter.prototype = new Node;\nFilter.prototype.constructor = Filter;\n\n}); // module: nodes/filter.js\n\nrequire.register(\"nodes/index.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nexports.Node = require('./node');\nexports.Tag = require('./tag');\nexports.Code = require('./code');\nexports.Each = require('./each');\nexports.Case = require('./case');\nexports.Text = require('./text');\nexports.Block = require('./block');\nexports.Mixin = require('./mixin');\nexports.Filter = require('./filter');\nexports.Comment = require('./comment');\nexports.Literal = require('./literal');\nexports.BlockComment = require('./block-comment');\nexports.Doctype = require('./doctype');\n\n}); // module: nodes/index.js\n\nrequire.register(\"nodes/literal.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Literal\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Literal` node with the given `str.\n *\n * @param {String} str\n * @api public\n */\n\nvar Literal = module.exports = function Literal(str) {\n  this.str = str\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\\n|\\r\\n/g, \"\\\\n\")\n    .replace(/'/g, \"\\\\'\");\n};\n\n/**\n * Inherit from `Node`.\n */\n\nLiteral.prototype = new Node;\nLiteral.prototype.constructor = Literal;\n\n\n}); // module: nodes/literal.js\n\nrequire.register(\"nodes/mixin.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Mixin\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Attrs = require('./attrs');\n\n/**\n * Initialize a new `Mixin` with `name` and `block`.\n *\n * @param {String} name\n * @param {String} args\n * @param {Block} block\n * @api public\n */\n\nvar Mixin = module.exports = function Mixin(name, args, block, call){\n  this.name = name;\n  this.args = args;\n  this.block = block;\n  this.attrs = [];\n  this.call = call;\n};\n\n/**\n * Inherit from `Attrs`.\n */\n\nMixin.prototype = new Attrs;\nMixin.prototype.constructor = Mixin;\n\n\n\n}); // module: nodes/mixin.js\n\nrequire.register(\"nodes/node.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Node\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Initialize a `Node`.\n *\n * @api public\n */\n\nvar Node = module.exports = function Node(){};\n\n/**\n * Clone this node (return itself)\n *\n * @return {Node}\n * @api private\n */\n\nNode.prototype.clone = function(){\n  return this;\n};\n\n}); // module: nodes/node.js\n\nrequire.register(\"nodes/tag.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Tag\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Attrs = require('./attrs'),\n    Block = require('./block'),\n    inlineTags = require('../inline-tags');\n\n/**\n * Initialize a `Tag` node with the given tag `name` and optional `block`.\n *\n * @param {String} name\n * @param {Block} block\n * @api public\n */\n\nvar Tag = module.exports = function Tag(name, block) {\n  this.name = name;\n  this.attrs = [];\n  this.block = block || new Block;\n};\n\n/**\n * Inherit from `Attrs`.\n */\n\nTag.prototype = new Attrs;\nTag.prototype.constructor = Tag;\n\n\n/**\n * Clone this tag.\n *\n * @return {Tag}\n * @api private\n */\n\nTag.prototype.clone = function(){\n  var clone = new Tag(this.name, this.block.clone());\n  clone.line = this.line;\n  clone.attrs = this.attrs;\n  clone.textOnly = this.textOnly;\n  return clone;\n};\n\n/**\n * Check if this tag is an inline tag.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.isInline = function(){\n  return ~inlineTags.indexOf(this.name);\n};\n\n/**\n * Check if this tag's contents can be inlined.  Used for pretty printing.\n *\n * @return {Boolean}\n * @api private\n */\n\nTag.prototype.canInline = function(){\n  var nodes = this.block.nodes;\n\n  function isInline(node){\n    // Recurse if the node is a block\n    if (node.isBlock) return node.nodes.every(isInline);\n    return node.isText || (node.isInline && node.isInline());\n  }\n  \n  // Empty tag\n  if (!nodes.length) return true;\n  \n  // Text-only or inline-only tag\n  if (1 == nodes.length) return isInline(nodes[0]);\n  \n  // Multi-line inline-only tag\n  if (this.block.nodes.every(isInline)) {\n    for (var i = 1, len = nodes.length; i < len; ++i) {\n      if (nodes[i-1].isText && nodes[i].isText)\n        return false;\n    }\n    return true;\n  }\n  \n  // Mixed tag\n  return false;\n};\n}); // module: nodes/tag.js\n\nrequire.register(\"nodes/text.js\", function(module, exports, require){\n\n/*!\n * Jade - nodes - Text\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Node = require('./node');\n\n/**\n * Initialize a `Text` node with optional `line`.\n *\n * @param {String} line\n * @api public\n */\n\nvar Text = module.exports = function Text(line) {\n  this.val = '';\n  if ('string' == typeof line) this.val = line;\n};\n\n/**\n * Inherit from `Node`.\n */\n\nText.prototype = new Node;\nText.prototype.constructor = Text;\n\n\n/**\n * Flag as text.\n */\n\nText.prototype.isText = true;\n}); // module: nodes/text.js\n\nrequire.register(\"parser.js\", function(module, exports, require){\n\n/*!\n * Jade - Parser\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Lexer = require('./lexer')\n  , nodes = require('./nodes')\n  , utils = require('./utils');\n\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nvar Parser = exports = module.exports = function Parser(str, filename, options){\n  this.input = str;\n  this.lexer = new Lexer(str, options);\n  this.filename = filename;\n  this.blocks = {};\n  this.mixins = {};\n  this.options = options;\n  this.contexts = [this];\n};\n\n/**\n * Tags that may not contain tags.\n */\n\nvar textOnly = exports.textOnly = ['script', 'style'];\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n\n  /**\n   * Push `parser` onto the context stack,\n   * or pop and return a `Parser`.\n   */\n\n  context: function(parser){\n    if (parser) {\n      this.contexts.push(parser);\n    } else {\n      return this.contexts.pop();\n    }\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function(){\n    return this.lexer.advance();\n  },\n\n  /**\n   * Skip `n` tokens.\n   *\n   * @param {Number} n\n   * @api private\n   */\n\n  skip: function(n){\n    while (n--) this.advance();\n  },\n  \n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  \n  peek: function() {\n    return this.lookahead(1);\n  },\n  \n  /**\n   * Return lexer lineno.\n   *\n   * @return {Number}\n   * @api private\n   */\n  \n  line: function() {\n    return this.lexer.lineno;\n  },\n  \n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  \n  lookahead: function(n){\n    return this.lexer.lookahead(n);\n  },\n  \n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n  \n  parse: function(){\n    var block = new nodes.Block, parser;\n    block.line = this.line();\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n\n    if (parser = this.extending) {\n      this.context(parser);\n      var ast = parser.parse();\n      this.context();\n      // hoist mixins\n      for (var name in this.mixins)\n        ast.unshift(this.mixins[name]);\n      return ast;\n    }\n\n    return block;\n  },\n  \n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n  \n  expect: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      throw new Error('expected \"' + type + '\", but got \"' + this.peek().type + '\"');\n    }\n  },\n  \n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n  \n  accept: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n  \n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n  \n  parseExpr: function(){\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n      case 'mixin':\n        return this.parseMixin();\n      case 'block':\n        return this.parseBlock();\n      case 'case':\n        return this.parseCase();\n      case 'when':\n        return this.parseWhen();\n      case 'default':\n        return this.parseDefault();\n      case 'extends':\n        return this.parseExtends();\n      case 'include':\n        return this.parseInclude();\n      case 'doctype':\n        return this.parseDoctype();\n      case 'filter':\n        return this.parseFilter();\n      case 'comment':\n        return this.parseComment();\n      case 'text':\n        return this.parseText();\n      case 'each':\n        return this.parseEach();\n      case 'code':\n        return this.parseCode();\n      case 'call':\n        return this.parseCall();\n      case 'interpolation':\n        return this.parseInterpolation();\n      case 'yield':\n        this.advance();\n        var block = new nodes.Block;\n        block.yield = true;\n        return block;\n      case 'id':\n      case 'class':\n        var tok = this.advance();\n        this.lexer.defer(this.lexer.tok('tag', 'div'));\n        this.lexer.defer(tok);\n        return this.parseExpr();\n      default:\n        throw new Error('unexpected token \"' + this.peek().type + '\"');\n    }\n  },\n  \n  /**\n   * Text\n   */\n  \n  parseText: function(){\n    var tok = this.expect('text')\n      , node = new nodes.Text(tok.val);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n\n  parseBlockExpansion: function(){\n    if (':' == this.peek().type) {\n      this.advance();\n      return new nodes.Block(this.parseExpr());\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n\n  parseCase: function(){\n    var val = this.expect('case').val\n      , node = new nodes.Case(val);\n    node.line = this.line();\n    node.block = this.block();\n    return node;\n  },\n\n  /**\n   * when\n   */\n\n  parseWhen: function(){\n    var val = this.expect('when').val\n    return new nodes.Case.When(val, this.parseBlockExpansion());\n  },\n  \n  /**\n   * default\n   */\n\n  parseDefault: function(){\n    this.expect('default');\n    return new nodes.Case.When('default', this.parseBlockExpansion());\n  },\n\n  /**\n   * code\n   */\n  \n  parseCode: function(){\n    var tok = this.expect('code')\n      , node = new nodes.Code(tok.val, tok.buffer, tok.escape)\n      , block\n      , i = 1;\n    node.line = this.line();\n    while (this.lookahead(i) && 'newline' == this.lookahead(i).type) ++i;\n    block = 'indent' == this.lookahead(i).type;\n    if (block) {\n      this.skip(i-1);\n      node.block = this.block();\n    }\n    return node;\n  },\n  \n  /**\n   * comment\n   */\n  \n  parseComment: function(){\n    var tok = this.expect('comment')\n      , node;\n\n    if ('indent' == this.peek().type) {\n      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);\n    } else {\n      node = new nodes.Comment(tok.val, tok.buffer);\n    }\n\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * doctype\n   */\n  \n  parseDoctype: function(){\n    var tok = this.expect('doctype')\n      , node = new nodes.Doctype(tok.val);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * filter attrs? text-block\n   */\n  \n  parseFilter: function(){\n    var block\n      , tok = this.expect('filter')\n      , attrs = this.accept('attrs');\n\n    this.lexer.pipeless = true;\n    block = this.parseTextBlock();\n    this.lexer.pipeless = false;\n\n    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * tag ':' attrs? block\n   */\n  \n  parseASTFilter: function(){\n    var block\n      , tok = this.expect('tag')\n      , attrs = this.accept('attrs');\n\n    this.expect(':');\n    block = this.block();\n\n    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);\n    node.line = this.line();\n    return node;\n  },\n  \n  /**\n   * each block\n   */\n  \n  parseEach: function(){\n    var tok = this.expect('each')\n      , node = new nodes.Each(tok.code, tok.val, tok.key);\n    node.line = this.line();\n    node.block = this.block();\n    if (this.peek().type == 'code' && this.peek().val == 'else') {\n      this.advance();\n      node.alternative = this.block();\n    }\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n\n  parseExtends: function(){\n    var path = require('path')\n      , fs = require('fs')\n      , dirname = path.dirname\n      , basename = path.basename\n      , join = path.join;\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to extend templates');\n\n    var path = this.expect('extends').val.trim()\n      , dir = dirname(this.filename);\n\n    var path = join(dir, path + '.jade')\n      , str = fs.readFileSync(path, 'utf8')\n      , parser = new Parser(str, path, this.options);\n\n    parser.blocks = this.blocks;\n    parser.contexts = this.contexts;\n    this.extending = parser;\n\n    // TODO: null node\n    return new nodes.Literal('');\n  },\n\n  /**\n   * 'block' name block\n   */\n\n  parseBlock: function(){\n    var block = this.expect('block')\n      , mode = block.mode\n      , name = block.val.trim();\n\n    block = 'indent' == this.peek().type\n      ? this.block()\n      : new nodes.Block(new nodes.Literal(''));\n\n    var prev = this.blocks[name];\n\n    if (prev) {\n      switch (prev.mode) {\n        case 'append':\n          block.nodes = block.nodes.concat(prev.nodes);\n          prev = block;\n          break;\n        case 'prepend':\n          block.nodes = prev.nodes.concat(block.nodes);\n          prev = block;\n          break;\n      }\n    }\n\n    block.mode = mode;\n    return this.blocks[name] = prev || block;\n  },\n\n  /**\n   * include block?\n   */\n\n  parseInclude: function(){\n    var path = require('path')\n      , fs = require('fs')\n      , dirname = path.dirname\n      , basename = path.basename\n      , join = path.join;\n\n    var path = this.expect('include').val.trim()\n      , dir = dirname(this.filename);\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to use includes');\n\n    // no extension\n    if (!~basename(path).indexOf('.')) {\n      path += '.jade';\n    }\n\n    // non-jade\n    if ('.jade' != path.substr(-5)) {\n      var path = join(dir, path)\n        , str = fs.readFileSync(path, 'utf8');\n      return new nodes.Literal(str);\n    }\n\n    var path = join(dir, path)\n      , str = fs.readFileSync(path, 'utf8')\n     , parser = new Parser(str, path, this.options);\n    parser.blocks = utils.merge({}, this.blocks);\n    parser.mixins = this.mixins;\n\n    this.context(parser);\n    var ast = parser.parse();\n    this.context();\n    ast.filename = path;\n\n    if ('indent' == this.peek().type) {\n      ast.includeBlock().push(this.block());\n    }\n\n    return ast;\n  },\n\n  /**\n   * call ident block\n   */\n\n  parseCall: function(){\n    var tok = this.expect('call')\n      , name = tok.val\n      , args = tok.args\n      , mixin = new nodes.Mixin(name, args, new nodes.Block, true);\n\n    this.tag(mixin);\n    if (mixin.block.isEmpty()) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n\n  parseMixin: function(){\n    var tok = this.expect('mixin')\n      , name = tok.val\n      , args = tok.args\n      , mixin;\n\n    // definition\n    if ('indent' == this.peek().type) {\n      mixin = new nodes.Mixin(name, args, this.block(), false);\n      this.mixins[name] = mixin;\n      return mixin;\n    // call\n    } else {\n      return new nodes.Mixin(name, args, null, true);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n\n  parseTextBlock: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    var spaces = this.expect('indent').val;\n    if (null == this._spaces) this._spaces = spaces;\n    var indent = Array(spaces - this._spaces + 1).join(' ');\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'newline':\n          this.advance();\n          break;\n        case 'indent':\n          this.parseTextBlock().nodes.forEach(function(node){\n            block.push(node);\n          });\n          break;\n        default:\n          var text = new nodes.Text(indent + this.advance().val);\n          text.line = this.line();\n          block.push(text);\n      }\n    }\n\n    if (spaces == this._spaces) this._spaces = null;\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n  \n  block: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  \n  parseInterpolation: function(){\n    var tok = this.advance();\n    var tag = new nodes.Tag(tok.val);\n    tag.buffer = true;\n    return this.tag(tag);\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  \n  parseTag: function(){\n    // ast-filter look-ahead\n    var i = 2;\n    if ('attrs' == this.lookahead(i).type) ++i;\n    if (':' == this.lookahead(i).type) {\n      if ('indent' == this.lookahead(++i).type) {\n        return this.parseASTFilter();\n      }\n    }\n\n    var tok = this.advance()\n      , tag = new nodes.Tag(tok.val);\n\n    tag.selfClosing = tok.selfClosing;\n\n    return this.tag(tag);\n  },\n\n  /**\n   * Parse tag.\n   */\n\n  tag: function(tag){\n    var dot;\n\n    tag.line = this.line();\n\n    // (attrs | class | id)*\n    out:\n      while (true) {\n        switch (this.peek().type) {\n          case 'id':\n          case 'class':\n            var tok = this.advance();\n            tag.setAttribute(tok.type, \"'\" + tok.val + \"'\");\n            continue;\n          case 'attrs':\n            var tok = this.advance()\n              , obj = tok.attrs\n              , escaped = tok.escaped\n              , names = Object.keys(obj);\n\n            if (tok.selfClosing) tag.selfClosing = true;\n\n            for (var i = 0, len = names.length; i < len; ++i) {\n              var name = names[i]\n                , val = obj[name];\n              tag.setAttribute(name, val, escaped[name]);\n            }\n            continue;\n          default:\n            break out;\n        }\n      }\n\n    // check immediate '.'\n    if ('.' == this.peek().val) {\n      dot = tag.textOnly = true;\n      this.advance();\n    }\n\n    // (text | code | ':')?\n    switch (this.peek().type) {\n      case 'text':\n        tag.block.push(this.parseText());\n        break;\n      case 'code':\n        tag.code = this.parseCode();\n        break;\n      case ':':\n        this.advance();\n        tag.block = new nodes.Block;\n        tag.block.push(this.parseExpr());\n        break;\n    }\n\n    // newline*\n    while ('newline' == this.peek().type) this.advance();\n\n    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);\n\n    // script special-case\n    if ('script' == tag.name) {\n      var type = tag.getAttribute('type');\n      if (!dot && type && 'text/javascript' != type.replace(/^['\"]|['\"]$/g, '')) {\n        tag.textOnly = false;\n      }\n    }\n\n    // block?\n    if ('indent' == this.peek().type) {\n      if (tag.textOnly) {\n        this.lexer.pipeless = true;\n        tag.block = this.parseTextBlock();\n        this.lexer.pipeless = false;\n      } else {\n        var block = this.block();\n        if (tag.block) {\n          for (var i = 0, len = block.nodes.length; i < len; ++i) {\n            tag.block.push(block.nodes[i]);\n          }\n        } else {\n          tag.block = block;\n        }\n      }\n    }\n    \n    return tag;\n  }\n};\n\n}); // module: parser.js\n\nrequire.register(\"runtime.js\", function(module, exports, require){\n\n/*!\n * Jade - runtime\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Lame Array.isArray() polyfill for now.\n */\n\nif (!Array.isArray) {\n  Array.isArray = function(arr){\n    return '[object Array]' == Object.prototype.toString.call(arr);\n  };\n}\n\n/**\n * Lame Object.keys() polyfill for now.\n */\n\nif (!Object.keys) {\n  Object.keys = function(obj){\n    var arr = [];\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        arr.push(key);\n      }\n    }\n    return arr;\n  }\n}\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    ac = ac.filter(nulls);\n    bc = bc.filter(nulls);\n    a['class'] = ac.concat(bc).join(' ');\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null;\n}\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n * @api private\n */\n\nexports.attrs = function attrs(obj, escaped){\n  var buf = []\n    , terse = obj.terse;\n\n  delete obj.terse;\n  var keys = Object.keys(obj)\n    , len = keys.length;\n\n  if (len) {\n    buf.push('');\n    for (var i = 0; i < len; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('boolean' == typeof val || null == val) {\n        if (val) {\n          terse\n            ? buf.push(key)\n            : buf.push(key + '=\"' + key + '\"');\n        }\n      } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n        buf.push(key + \"='\" + JSON.stringify(val) + \"'\");\n      } else if ('class' == key && Array.isArray(val)) {\n        buf.push(key + '=\"' + exports.escape(val.join(' ')) + '\"');\n      } else if (escaped && escaped[key]) {\n        buf.push(key + '=\"' + exports.escape(val) + '\"');\n      } else {\n        buf.push(key + '=\"' + val + '\"');\n      }\n    }\n  }\n\n  return buf.join(' ');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function escape(html){\n  return String(html)\n    .replace(/&(?!(\\w+|\\#\\d+);)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno){\n  if (!filename) throw err;\n\n  var context = 3\n    , str = require('fs').readFileSync(filename, 'utf8')\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\n}); // module: runtime.js\n\nrequire.register(\"self-closing.js\", function(module, exports, require){\n\n/*!\n * Jade - self closing tags\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\nmodule.exports = [\n    'meta'\n  , 'img'\n  , 'link'\n  , 'input'\n  , 'source'\n  , 'area'\n  , 'base'\n  , 'col'\n  , 'br'\n  , 'hr'\n];\n}); // module: self-closing.js\n\nrequire.register(\"utils.js\", function(module, exports, require){\n\n/*!\n * Jade - utils\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Convert interpolation in the given string to JavaScript.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar interpolate = exports.interpolate = function(str){\n  return str.replace(/(_SLASH_)?([#!]){(.*?)}/g, function(str, escape, flag, code){\n    code = code\n      .replace(/\\\\'/g, \"'\")\n      .replace(/_SLASH_/g, '\\\\');\n\n    return escape\n      ? str.slice(7)\n      : \"' + \"\n        + ('!' == flag ? '' : 'escape')\n        + \"((interp = \" + code\n        + \") == null ? '' : interp) + '\";\n  });\n};\n\n/**\n * Escape single quotes in `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nvar escape = exports.escape = function(str) {\n  return str.replace(/'/g, \"\\\\'\");\n};\n\n/**\n * Interpolate, and escape the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.text = function(str){\n  return interpolate(escape(str));\n};\n\n/**\n * Merge `b` into `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object}\n * @api public\n */\n\nexports.merge = function(a, b) {\n  for (var key in b) a[key] = b[key];\n  return a;\n};\n\n\n}); // module: utils.js\n\nwindow.jade = require(\"jade\");\n})();\n"]],"start1":0,"start2":0,"length1":0,"length2":76246}]],"length":76246}
