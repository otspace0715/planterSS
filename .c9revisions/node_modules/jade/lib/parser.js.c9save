{"ts":1369127664242,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Jade - Parser\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Lexer = require('./lexer')\n  , nodes = require('./nodes')\n  , utils = require('./utils')\n  , filters = require('./filters')\n  , path = require('path')\n  , extname = path.extname;\n\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nvar Parser = exports = module.exports = function Parser(str, filename, options){\n  this.input = str;\n  this.lexer = new Lexer(str, options);\n  this.filename = filename;\n  this.blocks = {};\n  this.mixins = {};\n  this.options = options;\n  this.contexts = [this];\n};\n\n/**\n * Tags that may not contain tags.\n */\n\nvar textOnly = exports.textOnly = ['script', 'style'];\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n\n  /**\n   * Push `parser` onto the context stack,\n   * or pop and return a `Parser`.\n   */\n\n  context: function(parser){\n    if (parser) {\n      this.contexts.push(parser);\n    } else {\n      return this.contexts.pop();\n    }\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function(){\n    return this.lexer.advance();\n  },\n\n  /**\n   * Skip `n` tokens.\n   *\n   * @param {Number} n\n   * @api private\n   */\n\n  skip: function(n){\n    while (n--) this.advance();\n  },\n\n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  peek: function() {\n    return this.lookahead(1);\n  },\n\n  /**\n   * Return lexer lineno.\n   *\n   * @return {Number}\n   * @api private\n   */\n\n  line: function() {\n    return this.lexer.lineno;\n  },\n\n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n\n  lookahead: function(n){\n    return this.lexer.lookahead(n);\n  },\n\n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  parse: function(){\n    var block = new nodes.Block, parser;\n    block.line = this.line();\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n\n    if (parser = this.extending) {\n      this.context(parser);\n      var ast = parser.parse();\n      this.context();\n      // hoist mixins\n      for (var name in this.mixins)\n        ast.unshift(this.mixins[name]);\n      return ast;\n    }\n\n    return block;\n  },\n\n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  expect: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      throw new Error('expected \"' + type + '\", but got \"' + this.peek().type + '\"');\n    }\n  },\n\n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  accept: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n\n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n\n  parseExpr: function(){\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n      case 'mixin':\n        return this.parseMixin();\n      case 'block':\n        return this.parseBlock();\n      case 'case':\n        return this.parseCase();\n      case 'when':\n        return this.parseWhen();\n      case 'default':\n        return this.parseDefault();\n      case 'extends':\n        return this.parseExtends();\n      case 'include':\n        return this.parseInclude();\n      case 'doctype':\n        return this.parseDoctype();\n      case 'filter':\n        return this.parseFilter();\n      case 'comment':\n        return this.parseComment();\n      case 'text':\n        return this.parseText();\n      case 'each':\n        return this.parseEach();\n      case 'code':\n        return this.parseCode();\n      case 'call':\n        return this.parseCall();\n      case 'interpolation':\n        return this.parseInterpolation();\n      case 'yield':\n        this.advance();\n        var block = new nodes.Block;\n        block.yield = true;\n        return block;\n      case 'id':\n      case 'class':\n        var tok = this.advance();\n        this.lexer.defer(this.lexer.tok('tag', 'div'));\n        this.lexer.defer(tok);\n        return this.parseExpr();\n      default:\n        throw new Error('unexpected token \"' + this.peek().type + '\"');\n    }\n  },\n\n  /**\n   * Text\n   */\n\n  parseText: function(){\n    var tok = this.expect('text');\n    var node = new nodes.Text(tok.val);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n\n  parseBlockExpansion: function(){\n    if (':' == this.peek().type) {\n      this.advance();\n      return new nodes.Block(this.parseExpr());\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n\n  parseCase: function(){\n    var val = this.expect('case').val;\n    var node = new nodes.Case(val);\n    node.line = this.line();\n    node.block = this.block();\n    return node;\n  },\n\n  /**\n   * when\n   */\n\n  parseWhen: function(){\n    var val = this.expect('when').val\n    return new nodes.Case.When(val, this.parseBlockExpansion());\n  },\n\n  /**\n   * default\n   */\n\n  parseDefault: function(){\n    this.expect('default');\n    return new nodes.Case.When('default', this.parseBlockExpansion());\n  },\n\n  /**\n   * code\n   */\n\n  parseCode: function(){\n    var tok = this.expect('code');\n    var node = new nodes.Code(tok.val, tok.buffer, tok.escape);\n    var block;\n    var i = 1;\n    node.line = this.line();\n    while (this.lookahead(i) && 'newline' == this.lookahead(i).type) ++i;\n    block = 'indent' == this.lookahead(i).type;\n    if (block) {\n      this.skip(i-1);\n      node.block = this.block();\n    }\n    return node;\n  },\n\n  /**\n   * comment\n   */\n\n  parseComment: function(){\n    var tok = this.expect('comment');\n    var node;\n\n    if ('indent' == this.peek().type) {\n      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);\n    } else {\n      node = new nodes.Comment(tok.val, tok.buffer);\n    }\n\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   * doctype\n   */\n\n  parseDoctype: function(){\n    var tok = this.expect('doctype');\n    var node = new nodes.Doctype(tok.val);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   * filter attrs? text-block\n   */\n\n  parseFilter: function(){\n    var tok = this.expect('filter');\n    var attrs = this.accept('attrs');\n    var block;\n\n    this.lexer.pipeless = true;\n    block = this.parseTextBlock();\n    this.lexer.pipeless = false;\n\n    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);\n    node.line = this.line();\n    return node;\n  },\n\n  /**\n   * each block\n   */\n\n  parseEach: function(){\n    var tok = this.expect('each');\n    var node = new nodes.Each(tok.code, tok.val, tok.key);\n    node.line = this.line();\n    node.block = this.block();\n    if (this.peek().type == 'code' && this.peek().val == 'else') {\n      this.advance();\n      node.alternative = this.block();\n    }\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n\n  parseExtends: function(){\n    var path = require('path');\n    var fs = require('fs');\n    var dirname = path.dirname;\n    var basename = path.basename;\n    var join = path.join;\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to extend templates');\n\n    path = this.expect('extends').val.trim();\n    var dir = dirname(this.filename);\n\n    path = join(dir, path + '.jade');\n    var str = fs.readFileSync(path, 'utf8');\n    var parser = new Parser(str, path, this.options);\n\n    parser.blocks = this.blocks;\n    parser.contexts = this.contexts;\n    this.extending = parser;\n\n    // TODO: null node\n    return new nodes.Literal('');\n  },\n\n  /**\n   * 'block' name block\n   */\n\n  parseBlock: function(){\n    var block = this.expect('block');\n    var mode = block.mode;\n    var name = block.val.trim();\n\n    block = 'indent' == this.peek().type\n      ? this.block()\n      : new nodes.Block(new nodes.Literal(''));\n\n    var prev = this.blocks[name];\n\n    if (prev) {\n      switch (prev.mode) {\n        case 'append':\n          block.nodes = block.nodes.concat(prev.nodes);\n          prev = block;\n          break;\n        case 'prepend':\n          block.nodes = prev.nodes.concat(block.nodes);\n          prev = block;\n          break;\n      }\n    }\n\n    block.mode = mode;\n    return this.blocks[name] = prev || block;\n  },\n\n  /**\n   * include block?\n   */\n\n  parseInclude: function(){\n    var path = require('path');\n    var fs = require('fs');\n    var dirname = path.dirname;\n    var basename = path.basename;\n    var join = path.join;\n    var str;\n\n    path = this.expect('include').val.trim();\n    var dir = dirname(this.filename);\n\n    if (!this.filename)\n      throw new Error('the \"filename\" option is required to use includes');\n\n    // no extension\n    if (!~basename(path).indexOf('.')) {\n      path += '.jade';\n    }\n\n    // non-jade\n    if ('.jade' != path.substr(-5)) {\n      path = join(dir, path);\n      str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n      var ext = extname(path).slice(1);\n      var filter = filters[ext];\n      if (filter) str = filter(str, { filename: path }).replace(/\\\\n/g, '\\n');\n      return new nodes.Literal(str);\n    }\n\n    path = join(dir, path);\n    str = fs.readFileSync(path, 'utf8');\n    var parser = new Parser(str, path, this.options);\n    parser.blocks = utils.merge({}, this.blocks);\n    parser.mixins = this.mixins;\n\n    this.context(parser);\n    var ast = parser.parse();\n    this.context();\n    ast.filename = path;\n\n    if ('indent' == this.peek().type) {\n      ast.includeBlock().push(this.block());\n    }\n\n    return ast;\n  },\n\n  /**\n   * call ident block\n   */\n\n  parseCall: function(){\n    var tok = this.expect('call');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin = new nodes.Mixin(name, args, new nodes.Block, true);\n\n    this.tag(mixin);\n    if (mixin.block.isEmpty()) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n\n  parseMixin: function(){\n    var tok = this.expect('mixin');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin;\n\n    // definition\n    if ('indent' == this.peek().type) {\n      mixin = new nodes.Mixin(name, args, this.block(), false);\n      this.mixins[name] = mixin;\n      return mixin;\n    // call\n    } else {\n      return new nodes.Mixin(name, args, null, true);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n\n  parseTextBlock: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    var spaces = this.expect('indent').val;\n    if (null == this._spaces) this._spaces = spaces;\n    var indent = Array(spaces - this._spaces + 1).join(' ');\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'newline':\n          this.advance();\n          break;\n        case 'indent':\n          this.parseTextBlock().nodes.forEach(function(node){\n            block.push(node);\n          });\n          break;\n        default:\n          var text = new nodes.Text(indent + this.advance().val);\n          text.line = this.line();\n          block.push(text);\n      }\n    }\n\n    if (spaces == this._spaces) this._spaces = null;\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n\n  block: function(){\n    var block = new nodes.Block;\n    block.line = this.line();\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else {\n        block.push(this.parseExpr());\n      }\n    }\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseInterpolation: function(){\n    var tok = this.advance();\n    var tag = new nodes.Tag(tok.val);\n    tag.buffer = true;\n    return this.tag(tag);\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseTag: function(){\n    // ast-filter look-ahead\n    var i = 2;\n    if ('attrs' == this.lookahead(i).type) ++i;\n\n    var tok = this.advance();\n    var tag = new nodes.Tag(tok.val);\n\n    tag.selfClosing = tok.selfClosing;\n\n    return this.tag(tag);\n  },\n\n  /**\n   * Parse tag.\n   */\n\n  tag: function(tag){\n    var dot;\n\n    tag.line = this.line();\n\n    // (attrs | class | id)*\n    out:\n      while (true) {\n        switch (this.peek().type) {\n          case 'id':\n          case 'class':\n            var tok = this.advance();\n            tag.setAttribute(tok.type, \"'\" + tok.val + \"'\");\n            continue;\n          case 'attrs':\n            var tok = this.advance()\n              , obj = tok.attrs\n              , escaped = tok.escaped\n              , names = Object.keys(obj);\n\n            if (tok.selfClosing) tag.selfClosing = true;\n\n            for (var i = 0, len = names.length; i < len; ++i) {\n              var name = names[i]\n                , val = obj[name];\n              tag.setAttribute(name, val, escaped[name]);\n            }\n            continue;\n          default:\n            break out;\n        }\n      }\n\n    // check immediate '.'\n    if ('.' == this.peek().val) {\n      dot = tag.textOnly = true;\n      this.advance();\n    }\n\n    // (text | code | ':')?\n    switch (this.peek().type) {\n      case 'text':\n        tag.block.push(this.parseText());\n        break;\n      case 'code':\n        tag.code = this.parseCode();\n        break;\n      case ':':\n        this.advance();\n        tag.block = new nodes.Block;\n        tag.block.push(this.parseExpr());\n        break;\n    }\n\n    // newline*\n    while ('newline' == this.peek().type) this.advance();\n\n    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);\n\n    // script special-case\n    if ('script' == tag.name) {\n      var type = tag.getAttribute('type');\n      if (!dot && type && 'text/javascript' != type.replace(/^['\"]|['\"]$/g, '')) {\n        tag.textOnly = false;\n      }\n    }\n\n    // block?\n    if ('indent' == this.peek().type) {\n      if (tag.textOnly) {\n        this.lexer.pipeless = true;\n        tag.block = this.parseTextBlock();\n        this.lexer.pipeless = false;\n      } else {\n        var block = this.block();\n        if (tag.block) {\n          for (var i = 0, len = block.nodes.length; i < len; ++i) {\n            tag.block.push(block.nodes[i]);\n          }\n        } else {\n          tag.block = block;\n        }\n      }\n    }\n\n    return tag;\n  }\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":14661}]],"length":14661}
