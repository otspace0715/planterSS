{"ts":1369473160682,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * @author      Created by Marcus Spiegel <marcus.spiegel@gmail.com> on 2011-03-25.\n * @link        https://github.com/mashpie/i18n-node\n * @license     http://opensource.org/licenses/MIT\n *\n * @version     0.4.0\n */\n\n// dependencies and \"private\" vars\nvar vsprintf = require('sprintf').vsprintf,\n    fs = require('fs'),\n    url = require('url'),\n    path = require('path'),\n    debug = require('debug')('i18n:debug'),\n    warn = require('debug')('i18n:warn'),\n    error = require('debug')('i18n:error'),\n    locales = {},\n    api = ['__', '__n', 'getLocale', 'setLocale', 'getCatalog'],\n    pathsep = path.sep || '/', // ---> means win support will be available in node 0.8.x and above\n    defaultLocale, updateFiles, cookiename, extension, directory;\n\n// public exports\nvar i18n = exports;\n\ni18n.version = '0.4.0';\n\ni18n.configure = function i18nConfigure(opt) {\n\n  // you may register helpers in global scope, up to you\n  if (typeof opt.register === 'object') {\n    applyAPItoObject(opt.register);\n  }\n\n  // sets a custom cookie name to parse locale settings from\n  cookiename = (typeof opt.cookie === 'string') ? opt.cookie : null;\n\n  // where to store json files\n  directory = (typeof opt.directory === 'string') ? opt.directory : __dirname + pathsep + 'locales';\n\n  // write new locale information to disk\n  updateFiles = (typeof opt.updateFiles === 'boolean') ? opt.updateFiles : true;\n\n  // where to store json files\n  extension = (typeof opt.extension === 'string') ? opt.extension : '.json';\n\n  // setting defaultLocale\n  defaultLocale = (typeof opt.defaultLocale === 'string') ? opt.defaultLocale : 'en';\n\n  // implicitly read all locales\n  if (typeof opt.locales === 'object') {\n    opt.locales.forEach(function (l) {\n      read(l);\n    });\n  }\n};\n\ni18n.init = function i18nInit(request, response, next) {\n  if (typeof request === 'object') {\n    guessLanguage(request);\n\n    if (typeof response === 'object') {\n      applyAPItoObject(request, response);\n\n      // register locale to res.locals so hbs helpers know this.locale\n      if (!response.locale) response.locale = request.locale;\n\n      if (response.locals) {\n        applyAPItoObject(request, response.locals);\n\n        // register locale to res.locals so hbs helpers know this.locale\n        if (!response.locals.locale) response.locals.locale = request.locale;\n      }\n    }\n  }\n\n  if (typeof next === 'function') {\n    next();\n  }\n};\n\ni18n.__ = function i18nTranslate(phrase) {\n  // get translated message with locale from scope (deprecated) or object\n  var msg = translate(getLocaleFromObject(this), phrase);\n\n  // if we have extra arguments with strings to get replaced,\n  // an additional substition injects those strings afterwards\n  if (arguments.length > 1) {\n    msg = vsprintf(msg, Array.prototype.slice.call(arguments, 1));\n  }\n  return msg;\n};\n\ni18n.__n = function i18nTranslatePlural(singular, plural, count) {\n  // get translated message with locale from scope (deprecated) or object\n  var msg = translate(getLocaleFromObject(this), singular, plural);\n\n  // parse translation and replace all digets '%d' by `count`\n  // this also replaces extra strings '%%s' to parseble '%s' for next step\n  // simplest 2 form implementation of plural, like https://developer.mozilla.org/en/docs/Localization_and_Plurals#Plural_rule_.231_.282_forms.29\n  if (parseInt(count, 10) > 1) {\n    msg = vsprintf(msg.other, [count]);\n  } else {\n    msg = vsprintf(msg.one, [count]);\n  }\n\n  // if we have extra arguments with strings to get replaced,\n  // an additional substition injects those strings afterwards\n  if (arguments.length > 3) {\n    msg = vsprintf(msg, Array.prototype.slice.call(arguments, 3));\n  }\n\n  return msg;\n};\n\ni18n.setLocale = function i18nSetLocale(locale_or_request, locale) {\n  var target_locale = locale_or_request,\n      request;\n\n  // called like setLocale(req, 'en')\n  if (locale_or_request && typeof locale === 'string' && locales[locale]) {\n    request = locale_or_request;\n    target_locale = locale;\n  }\n\n  // called like req.setLocale('en')\n  if (locale === undefined && typeof this.locale === 'string' && typeof locale_or_request === 'string') {\n    request = this;\n    target_locale = locale_or_request;\n  }\n\n  if (locales[target_locale]) {\n\n    // called like setLocale('en')\n    if (request === undefined) {\n      defaultLocale = target_locale;\n    }\n    else {\n      request.locale = target_locale;\n    }\n  }\n  return i18n.getLocale(request);\n};\n\ni18n.getLocale = function i18nGetLocale(request) {\n\n  // called like getLocale(req)\n  if (request && request.locale) {\n    return request.locale;\n  }\n\n  // called like req.getLocale()\n  if (request === undefined && typeof this.locale === 'string') {\n    return this.locale;\n  }\n\n  // called like getLocale()\n  return defaultLocale;\n};\n\ni18n.getCatalog = function i18nGetCatalog(locale_or_request, locale) {\n  var target_locale = locale_or_request;\n\n  // called like getCatalog(req)\n  if (typeof locale_or_request === 'object' && typeof locale_or_request.locale === 'string') {\n    target_locale = locale_or_request.locale;\n  }\n\n  // called like getCatalog(req, 'en')\n  if (typeof locale_or_request === 'object' && typeof locale === 'string') {\n    target_locale = locale;\n  }\n\n  // called like req.getCatalog()\n  if (locale === undefined && typeof this.locale === 'string') {\n    target_locale = this.locale;\n  }\n\n  // called like req.getCatalog('en')\n  if (locale === undefined && typeof locale_or_request === 'string') {\n    target_locale = locale_or_request;\n  }\n\n  // called like getCatalog()\n  if (target_locale === undefined || target_locale === '') {\n    return locales;\n  }\n\n  if (locales[target_locale]) {\n    return locales[target_locale];\n  } else {\n    logWarn('No catalog found for \"' + target_locale + '\"');\n    return false;\n  }\n};\n\ni18n.overrideLocaleFromQuery = function (req) {\n  if (req === null) {\n    return;\n  }\n  var urlObj = url.parse(req.url, true);\n  if (urlObj.query.locale) {\n    logDebug(\"Overriding locale from query: \" + urlObj.query.locale);\n    i18n.setLocale(req, urlObj.query.locale.toLowerCase());\n  }\n};\n\n// ===================\n// = private methods =\n// ===================\n\n/**\n * registers all public API methods to a given response object when not already declared\n */\n\nfunction applyAPItoObject(request, response) {\n\n  // attach to itself if not provided\n  var object = response || request;\n  api.forEach(function (method) {\n\n    // be kind rewind, or better not touch anything already exiting\n    if (!object[method]) {\n      object[method] = function () {\n        return i18n[method].apply(request, arguments);\n      };\n    }\n  });\n}\n\n/**\n * guess language setting based on http headers\n */\n\nfunction guessLanguage(request) {\n  if (typeof request === 'object') {\n    var language_header = request.headers['accept-language'],\n        languages = [],\n        regions = [];\n\n    request.languages = [defaultLocale];\n    request.regions = [defaultLocale];\n    request.language = defaultLocale;\n    request.region = defaultLocale;\n\n    if (language_header) {\n      language_header.split(',').forEach(function (l) {\n        var header = l.split(';', 1)[0],\n            lr = header.split('-', 2);\n        if (lr[0]) {\n          languages.push(lr[0].toLowerCase());\n        }\n        if (lr[1]) {\n          regions.push(lr[1].toLowerCase());\n        }\n      });\n\n      if (languages.length > 0) {\n        request.languages = languages;\n        request.language = languages[0];\n      }\n\n      if (regions.length > 0) {\n        request.regions = regions;\n        request.region = regions[0];\n      }\n    }\n\n    // setting the language by cookie\n    if (cookiename && request.cookies && request.cookies[cookiename]) {\n      request.language = request.cookies[cookiename];\n    }\n\n    i18n.setLocale(request, request.language);\n  }\n}\n\n/**\n * searches for locale in given object\n */\n\nfunction getLocaleFromObject(obj) {\n  var locale;\n  if (obj && obj.scope) {\n    locale = obj.scope.locale;\n  }\n  if (obj && obj.locale) {\n    locale = obj.locale;\n  }\n  return locale;\n}\n\n/**\n * read locale file, translate a msg and write to fs if new\n */\n\nfunction translate(locale, singular, plural) {\n  if (locale === undefined) {\n    logWarn(\"WARN: No locale found - check the context of the call to __(). Using \" + defaultLocale + \" as current locale\");\n    locale = defaultLocale;\n  }\n\n  if (!locales[locale]) {\n    read(locale);\n  }\n\n  if (plural) {\n    if (!locales[locale][singular]) {\n      locales[locale][singular] = {\n        'one': singular,\n        'other': plural\n      };\n      write(locale);\n    }\n  }\n\n  if (!locales[locale][singular]) {\n    locales[locale][singular] = singular;\n    write(locale);\n  }\n  return locales[locale][singular];\n}\n\n/**\n * try reading a file\n */\n\nfunction read(locale) {\n  var localeFile = {},\n      file = getStorageFilePath(locale);\n  try {\n    logDebug('read ' + file + ' for locale: ' + locale);\n    localeFile = fs.readFileSync(file);\n    try {\n      // parsing filecontents to locales[locale]\n      locales[locale] = JSON.parse(localeFile);\n    } catch (parseError) {\n      logError('unable to parse locales from file (maybe ' + file + ' is empty or invalid json?): ', e);\n    }\n  } catch (readError) {\n    // unable to read, so intialize that file\n    // locales[locale] are already set in memory, so no extra read required\n    // or locales[locale] are empty, which initializes an empty locale.json file\n    logDebug('initializing ' + file);\n    write(locale);\n  }\n}\n\n/**\n * try writing a file in a created directory\n */\n\nfunction write(locale) {\n  var stats, target, tmp;\n\n  // don't write new locale information to disk if updateFiles isn't true\n  if (!updateFiles) {\n    return;\n  }\n\n  // creating directory if necessary\n  try {\n    stats = fs.lstatSync(directory);\n  } catch (e) {\n    logDebug('creating locales dir in: ' + directory);\n    fs.mkdirSync(directory, parseInt('755', 8));\n  }\n\n  // first time init has an empty file\n  if (!locales[locale]) {\n    locales[locale] = {};\n  }\n\n  // writing to tmp and rename on success\n  try {\n    target = getStorageFilePath(locale);\n    tmp = target + \".tmp\";\n    fs.writeFileSync(tmp, JSON.stringify(locales[locale], null, \"\\t\"), \"utf8\");\n    stats = fs.statSync(tmp);\n    if (stats.isFile()) {\n      fs.renameSync(tmp, target);\n    } else {\n      logError('unable to write locales to file (either ' + tmp + ' or ' + target + ' are not writeable?): ', e);\n    }\n  } catch (e) {\n    logError('unexpected error writing files (either ' + tmp + ' or ' + target + ' are not writeable?): ', e);\n  }\n}\n\n/**\n * basic normalization of filepath\n */\n\nfunction getStorageFilePath(locale) {\n  // changed API to use .json as default, #16\n  var ext = extension || '.json',\n      filepath = path.normalize(directory + pathsep + locale + ext),\n      filepathJS = path.normalize(directory + pathsep + locale + '.js');\n  // use .js as fallback if already existing\n  try {\n    if (fs.statSync(filepathJS)) {\n      logDebug('using existing file ' + filepathJS);\n      extension = '.js';\n      return filepathJS;\n    }\n  } catch (e) {\n    logDebug('will write to ' + filepath);\n  }\n  return filepath;\n}\n\n/**\n * Logging proxies\n */\n\nfunction logDebug(msg) {\n  debug(msg);\n}\n\nfunction logWarn(msg) {\n  warn(msg);\n}\n\nfunction logError(msg) {\n  error(msg);\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":11300}]],"length":11300}
